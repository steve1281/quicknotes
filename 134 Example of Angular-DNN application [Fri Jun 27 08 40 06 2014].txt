=== Starting a new Angular - DNN Application ===

    Document describing the steps to create an angular application in our environment.

    The reader should be familiar with building .NET applications and DNN IPC. An understanding of 
    basic javascript (refer to "132 Javascript Notes.txt") is needed.  "133 Merging DNN with Angular.txt" is
    a good reference here as well.
    
    {"author":"Steve Falcigno","date":"June 18, 2014"}

    This is **ONE** possible approach.

=== the app ===

  From Visual Studio Solution Explorer
  Right-Click the TbayTel Add New Folder "TicTacToe"
  Right-Click TicTacToe - Add New Item - (Visual Basic) - (Web User Control) "TicTacToe.ascx"  ([x] Place code in separate file) - Add
  This will create the traditional .NET controls. Modify for use in the DNN frame work.
  Open TicTacToe.ascx.vb.  By default it will inherits UserControl. Change this:
    Inherits DotNetNuke.Entities.Modules.PortalModuleBase
    (note: this is being deprecated; there are other more modern classes. too bad, we use this one.)

  Under the directory TicTacToe, create the folder tree:
  
    .
    +---css
    +---img
    +---js
    +---lib

    Install angular under lib. (Of course this might change - if angular becomes a part of our DNN lib.)
    (for now, just copy it from a different application)
    
    Under js, create a folder called "controllers". This is where we will put our controllers. 
    (as an aside, if you need directives... )
    
    
    Should end up looking like:
    
    .
    +---css
    +---img
    +---js
    ¦   +---controllers
    +---lib
        +---angular
            +---i18n
    
  Assuming we will want a "tictactoe" controller, lets create the necessary files.
  
  In the css folder, add app.css:
    ttt-wrapper
    {
    }
  (we will add more to this later)
  
  In the js folder, add app.js:
  
     'use strict';
      var tictactoeApp = angular.module('tictactoeApp', ['ngSanitize']);
      
   (we probably won't change this much. the names used are just the convention I stole from pluralsight training)
   
  In the js/controllers folder, add TicTacToeController.js :
  
     'use strict';

     tictactoeApp.controller('TicTacToeController',
       function TicTacToeController($scope) {
       } 
     );
    
    (this will get changed a lot)
    
    Your application may need many controllers; it will need at least one.

    Open TicTacToe.ascx, edit as source.
    
       Under the Control definition, add:
       <%@ Register TagPrefix="dnn" Namespace="DotNetNuke.Web.Client.ClientResourceManagement" Assembly="DotNetNuke.Web.Client" %>
    
       Now, the includes. DNN requires we use their special tags. (cause its a CMS and assembles the page on the fly, but I digress)
       Insert this near the top some place; after the Register above.
       
       <dnn:DnnCssInclude ID="DnnAPPCSS" 
        runat="server" 
        FilePath="~/DesktopModules/Tbaytel/TicTacToe/css/app.css" 
        ForceProvider="DnnFormTopProvider" 
        Priority="102" />

       <dnn:DnnJsInclude ID="DnnAngularSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/TbayTel/TicTacToe/lib/angular/angular.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="220" />
         
       <dnn:DnnJsInclude ID="DnnAngularSanitizeSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/TicTacToe/lib/angular/angular-sanitize.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="225" /> 
         
       <dnn:DnnJsInclude ID="DnnAppSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/TicTacToe/js/app.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="230" /> 
        
       <dnn:DnnJsInclude ID="DnnEventControllerSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/TicTacToe/js/controllers/TicTacToeController.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="235" /> 
         
      Next, and this is personal preference, add a wrapper div for content:
      
        <div class="ttt-wrapper">
            ...  your UI goes here ... 
        </div>
    
      I add a div for storing hidden ASP fields under that:
      
        <div class="hidden">
          <asp:HiddenField ID="hdnExample" runat="server" />
        </div>
      
      A spot for javascript:
      
      <script>
         $(document).ready(function() {
            // post dom load script
         });
      </script>
      
      And a place for css. (temporarily, should be moved to app.css)
      <style>
      
      </style>
      
      Notes: this is sufficient to have a "running" application. You can compile add it to DNN modules if you like.
      (it will pretty dull though; this compile is mainly to see if we screwed up anything)
      
      Quickly then, login as host/superuser account, go to the host page, extensions, create new, from control, answer the questions.
      Go to a test page.
      Add New Module
      scroll to TicTacToe, drag it onto the ContentPane
      
      You should see a remarkable empty module. Maybe add some text to your UI div:
      
       <div class="ttt-wrapper">
           <p>Hello World</p>
        </div>
    
      Lets add some angular to this, a simple test.
      
      In the file TicTacToeController.js, inside the function TicTacToeController, add
        
        $scope.Name = "Steve";
        
      Back in the markup (aka : TicTacToe.ascx) add a app and controller div.
      (yes I know they can be the same, I prefer to break it up this way)
      
      Like so:
          <div class="ttt-wrapper">
            <div ng-app="tictactoeApp">
              <div ng-controller="TicTacToeController">
                <p>Hello {{Name}} !</p>
              </div>
            </div>
          </div>

      The result will be:
      
         Hello Steve !
    
      Thus proving that angular is actually working and our controller is connected.
      
      Need a back end hook up. (to DNN and SQL Server.)
      
      Create a new folder:  App_Code\TbaytelServices\AccountInformation
      Create a file in there called AccountInformationProxy.cs
      (YES I said CS. as in C Sharp. We write our Web API stuff in C#. There are reasons. Ask.)
      
      (There are a number of ways to do this - this is one of them. In this one I am including 
       the routemapper and the storage class in one namespace and one file. This becomes unwieldy
       for larger projects - just use separate files in that case.)
       
      you will need, at a minimum:
      
         using DotNetNuke.Web.Api;
         using System.Collections.Generic;
         using System.Net.Http;
         using System.Web.Http;
         using TbaytelServices;
         
      create a namespace:
      
         namespace Services.AccountInformation
         {
           .... everything goes here....
         }

      inside here we will add three classes. a service, a storage, and a router
      The storage class:
      
          public class Name 
          {
             public string First {get; set;}
             public string Last { get; set; }
          }
      
      The service class:
      
          public class AccountInformationController : TbaytelApiController
            {
                [AllowAnonymous]
                [HttpGet]
                public List<Name> UserName() 
                {
                    var names = new List<Name>() { 
                            new Name {First="Steve", Last="Falcigno"}
                    };

                    return names;
                }
            }
          
    And the route mapper:
    
        public class RouteMapper : IServiceRouteMapper
        {
            public void RegisterRoutes(IMapRoute mapRouteManager)
            {
                mapRouteManager.MapHttpRoute(
                    moduleFolderName: "AccountInformation",
                    routeName: "Default",
                    url: "{controller}/{action}",
                    defaults: new { id = RouteParameter.Optional },
                    namespaces: new[] { "Services.AccountInformation" }
                );
            }   
        }

        
    Once this compiles ok, we can increase the intelligence of our angular controller (TicTacToeController.js).
    First, add the $http to the controller:
    
        tictactoeApp.controller('TicTacToeController',
            function TicTacToeController($scope, $http) {
    
    then, inside controller's function, add a serviceURL variable:
        
        var serviceURL = '//localhost/dnn/DesktopModules/AccountInformation/API/AccountInformation'
        
        (note: I think I will come up with a better more generic way of getting that:
        
             var serviceURL = "//"+location.hostname+location.pathname.substr(0, location.pathname.lastIndexOf("/"))+"/"
               + 'DesktopModules/AccountInformation/API/AccountInformation';

               )
       
    add function that calls the service:
    
        function getUser() {
            $http.get(serviceURL + "/Username").success(
                function (data) {
                    processReturnedUsers(data);
                }).error(function (x, s, msg) {
                    handleError(x, s, msg);
                });
        }
    
    and a handler it will call:
    
        function processReturnedUsers(data) {
            // scrape the first returned.
            $scope.Name = data[0].First;
            $scope.Name += " ";
            $scope.Name += data[0].Last;
        }

    finally, you will need to kick off this process. Note that its non-blocking (asynchronous), so you should
    keep some sort of default $scope.Name (there is one there already) in case the page loads before this call
    finishes. (unlikely in this case; but add a database call to the back end and becomes likely)
    
        // kick it off
        getUser();
        
    Again there are a lot of ways to do this - you don't need to break it into so many methods. I prefer to so when things 
    get a little more complicated they are nicely broken down.

    The module will return:
    
        Hello Steve Falcigno !
        
    Next we need to leverage the DNN back end. This can be done in AccountInformation
    add using:
        using DotNetNuke.Entities.Users;
        
    and changing the service call:
        public class AccountInformationController : TbaytelApiController
        {
            [AllowAnonymous]
            [HttpGet]
            public List<Name> UserName() 
            {
                var names = new List<Name>();

                var user = UserController.GetCurrentUserInfo();

                if (user.UserID == -1){
                    names = new List<Name>() { new Name {First="NOT LOGGED IN", Last=""} };
                } else {
                    names = new List<Name>() { new Name { First = user.FirstName, Last = user.LastName } };
                }
                
                return names;
            }
        }
    
    You can see how useful this is - we can validate the user (e.g. check role membership) and provide 
    some security. (and yes, there are other ways to do this too)
    
    Now I get:
       Hello NOT LOGGED IN !
    
    Hmm. Hang on, I will login as myself:
        Hello Steven Falcigno !
    
    That's better :-)
    
    The next step is to be able to fetch some data from the database. (technically, DNN is doing this, but lets used
    a stored procedure)
    
    First we will need a stored procedure. This is a bit of scope, but quickly, establish a query:
    example:
    
        SELECT a.*,c.*,u.* FROM dbo.Users u
        JOIN tbt.Customer c ON c.USERid = u.userid
        JOIN tbt.CustomerAccount a ON c.CustomerID = a.CustomerID
        WHERE u.userid=49464
    
    From this we will create a stored procedure:
    
        -- =============================================
        -- Author:		Steve Falcigno
        -- Create date: 6/18/2014
        -- Description:	Gets all the customeraccount records by userid
        -- =============================================
        CREATE PROCEDURE tbt.CustomerAccountByUserid_GET 
            -- Add the parameters for the stored procedure here
            @userid int
        AS
        BEGIN
            -- SET NOCOUNT ON added to prevent extra result sets from
            -- interfering with SELECT statements.
            SET NOCOUNT ON;

            -- Insert statements for procedure here
                SELECT a.*,c.*,u.* FROM dbo.Users u
                JOIN tbt.Customer c ON c.USERid = u.userid
                JOIN tbt.CustomerAccount a ON c.CustomerID = a.CustomerID
                WHERE u.userid=@userid
        
        END
    
    This results with a procedure we can call:
    
        EXEC [tbt].[CustomerAccountByUserid_GET]	@userid = 49464

    In the service (AccountInformationProxy.cs) add:
    
        using TBayTel; 
        using System;
        using System.Data;
        
     This will allow you to use our custom class for calling the database. And before you
     start prattling on about how you can do this without a custom class, please observe the 
     complete lack of mention of database in the following:

            Dictionary<string, object> param =   new Dictionary<string, object>();
            param.Add("userid", user.Userid);
            DataTable dt = CASqlUtil.execStoredProcDataTable("tbt.CustomerAccountByUserid_GET ",param);

     In order to use this, we should make a storage class. (you don't have to, its just a nice mini-pattern
     to use to enforce predictable code.)
     
     There is a lot of potential data here, lets just add some simple records for now:
     
           public class CustomerRecord 
           {
               public int BillPoint { get; set; }
               public string FriendlyName { get; set; }
               public string Email { get; set;}
           }

      Now to create a service method:
        [AllowAnonymous]
        [HttpGet]
        public List<CustomerRecord> CustomerAccounts() 
        {
             var records = new List<CustomerRecord>();

            // fetch data
            var user = UserController.GetCurrentUserInfo();
            if (user.UserID == -1) { 
                return records;
            }

            Dictionary<string, object> param =   new Dictionary<string, object>();
            param.Add("userid", user.UserID);
            DataTable dt;
            try {
                dt = CASqlUtil.execStoredProcDataTable("[tbt].[CustomerAccountByUserid_GET]",param);
            }
            catch (Exception e)
            {
                // should log this error and manage it - for now re-throw. @todo: proper error logging.
                throw e;
            }

           
            foreach (DataRow dr in dt.Rows)
            {
              if ((Boolean)dr["IsActive"])
              {
                var record = new CustomerRecord                
                {
                    BillPoint = (int)dr["BillPointID"],
                    FriendlyName = (string)dr["FriendlyName"],
                    Email = (string)dr["LoweredEmail"]
                };
                records.Add(record);
              }
            }

            return records;
        }
        
        Summary: get the DNN user, use the ID to call sproc that returns data from database, filter through returned
        records for active ones and build a list to be returned the caller.  If there is nothing, return an empty list.
        
        Next we need to capture this is the controller:
        add:   
            $scope.Records = [];
                    
        add:
            function getAccount() {
                $http.get(serviceURL + "/CustomerAccounts").success(
                    function (data) {
                        $scope.Records = data;
                    }).error(function (x, s, msg) {
                        handleError(x, s, msg);
                    });
            }
            getAccount();

        We can display this using an angular repeater. open the markup (TicTacToe.ascx), find the div
        with ng-controller, add:
        
            <div ng-repeat="record in Records">
              <strong>{{record.FriendlyName}}</strong>
                <p>{{record.BillPoint}} {{record.Email}}</p>
            </div>
        
        
        The output looks like:
        
            Hello Steven Falcigno !
            
            Home Phone
            11306175 steve1282@hotmail.com
            
            52243525 steve1282@hotmail.com

        Which is reasonable in this case.
   