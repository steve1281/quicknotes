=== Merging DNN with Angular ===

    Document describing the steps to create an angular application in our environment.
    This example will include a WebAPI to to feed the angular, and a DNN (IPC) Inter Process Communication
    integrated to receive the initial state.

    Most of this document is based on a module called PredictivePrequal.  The focus is 
    on the integration of DNN .NET -> angularjs -> WebAPI.  It does not go into any depth.
    
    The reader should be familiar with building .NET applications and DNN IPC. An understanding of 
    basic javascript (refer to "132 Javascript Notes.txt") is needed.
    
    {"author":"Steve Falcigno","date":"June 17, 2014"}

=== Directory Structure ===

    Working under the traditional DesktopModules\Tbaytel\<modulename> the following hierarchy is created:
    
    .
    +---css
    +---img
    +---js
    ¦   +---controllers
    +---lib
        +---angular
            +---i18n

    Notes:  We will probably migrate angular to a more global location within DNN.  This will mean the lib 
    folder will move and the include will change.
    
=== .NET Front end ===        

    The traditional .NET files (.ASCX and .ASCX.VB) live in the root (.) folder. Example:
        ./PredictivePrequal.ascx
        ./PredictivePrequal.ascx.vb

    The .vb file should be as sparse as possible in order to use IPC:    
    
        Imports DotNetNuke.Entities.Modules.Communications
        
        Partial Class DesktopModules_TbayTel_PredictivePrequal_PredictivePrequal
            Inherits DotNetNuke.Entities.Modules.PortalModuleBase
            Implements IModuleListener
            
            Public Sub OnModuleCommunication(s As Object, e As Communications.ModuleCommunicationEventArgs) Implements IModuleListener.OnModuleCommunication    
                If e.Sender = "PHONENUMBER" Then
                '' send data to the user control contained within.
                    phonenumber.Value = e.Value
                 End If
            End Sub
        End Class
    
    In this example, predictive prequal is receives messages , checks the sender, and assigns the value to a hidden 
    tag on the form. This tag will be available to the angular scripts. Note this is all done server side.   
    
    The ascx file is more complex.
    You will need to include, using the DNN custom tags, the js and css.
    For css:
    
      <dnn:DnnCssInclude ID="DnnAPPCSS" 
        runat="server" 
        FilePath="~/DesktopModules/Tbaytel/PredictivePrequal/css/app.css" 
        ForceProvider="DnnFormTopProvider" 
        Priority="102" />
        
    For javascript:
    
       <dnn:DnnJsInclude ID="DnnAngularSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/TbayTel/PredictivePrequal/lib/angular/angular.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="220" />
         
       <dnn:DnnJsInclude ID="DnnAngularSanitizeSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/PredictivePrequal/lib/angular/angular-sanitize.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="225" /> 
         
       <dnn:DnnJsInclude ID="DnnAppSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/PredictivePrequal/js/app.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="230" /> 
        
       <dnn:DnnJsInclude ID="DnnEventControllerSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/PredictivePrequal/js/controllers/PredictivePrequalController.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="235" />        
        
       <dnn:DnnJsInclude ID="DnnFiltersSessionInclude" 
         runat="server" 
         FilePath="~/DesktopModules/Tbaytel/PredictivePrequal/js/filters.js" 
         ForceProvider="DnnFormBottomProvider" 
         Priority="240" />        

    Note the use of "Priority=". This controls your load order, not the position of the tag in the markup. (annoying!)
    
    You will need a nsApp in a div  (the body tag is never available in DNN):
    
        <div class="container slider" ng-app="eventsApp">
        ... usual angular type stuff ...
        </div>
        
    You will need a place for your "hidden" .NET values:
    
       <div id="divData" runat="server">
            <asp:HiddenField ID="phonenumber" runat="server" />
       </div>
    
    Script section to transfer the .NET over to client side (convenience really).
    Note the transfer happens before the DOM check code.
    
        <script>
            var billingpoint = $("#<%=billingpoint.clientid%>").val();
            var phonenumber = $("#<%=phonenumber.ClientID%>").val();
            var subscriptionid = $("#<%=subscriptionid.clientid%>").val();
        
            $(document).ready(function () {
             .... local js ...
            });
    
        </script>
    
    Maybe some local style (should be in app.css or equivalent):
    Note: I tend toward local initials a dash and a typical name OR put the css in the global
    files and use more general names.
    
        <style>
           .pp-subtext
           {
               font-size: xx-small;
           }
           .pp-fat-margins
           {
               margin: 0px 0px 0px 5px;
           }
        </style>
    
    One last note before leaving this file. If you need to determine the folder name you can in this ugly fashion:
    
        <%=DotNetNuke.Common.Globals.NavigateURL(PortalSettings.HomeTabId)%>
        
        example:
    
        '<%=DotNetNuke.Common.Globals.NavigateURL(PortalSettings.HomeTabId)%>DesktopModules/TbayTel/PredictivePrequal/img/image_{{need}}.png'
    
=== JS Front end ===   

    This is an angular application, so you will need to code (at least) one controller. From the markup file you will have 
    a something similar to:

    <div class="container slider" ng-app="eventsApp">
        <div ng-controller="PredictivePrequalController">
           ...
        </div>
    </div
        
    To accommodate this, you will add a line to your app.js (./js/app.js) file:
    
         var eventsApp = angular.module('eventsApp', ['ngSanitize']);
         
    Then you can build the controller file (./js/controllers/PredictivePrequalController.js):
    
         eventsApp.controller('PredictivePrequalController',
              function PredictivePrequalController($scope,$http) {
              ...
         });
    
    You will want to use an init method which will read in the deposited values from the .NET.
    (this [sort of] acts like a page_load method for angular):
    
         $scope.init = function (phonenumber) {
          ...
         }
         $scope.init(phonenumber);
    
    Recall that we copied phonenumber in the <script> tags from the .NET hidden variables, before the 
    DOM finished loading (i.e. as fast as possible).
    
    To interface with the WebAPI back end, you use:
    For asynchronous loading:
    
        $http.get(serviceURL + "ServiceInfo?" +
              "paramType=" + servicetype +
              "&" + "paramValue=" + servicevalue).success(
        function (data) {
            processReturnedServices(data);
        }).error(function (x, s, msg) {
            handleError(x, s, msg);
        });
                
    For synchronous loading:
    
        var request = new XMLHttpRequest();
        request.open('GET', serviceURL + "ServiceUpSell", false);  // `false` makes the request synchronous
         request.setRequestHeader("Accept", "application/json");
        request.send(null);

        if (request.status === 200) {
            var text = request.responseText;
            $scope.upsells = JSON.parse(text);
        } else {
            alert('an error has occurred');
        }
    
        Ideally, your code doesn't use synchronous (blocking) calls. Note that angular doesn't support it; I had to 
        fall back on conventional js. USING THIS WILL BLOCK ALL THE JAVASCRIPT ON THE PAGE.
    
    Note that all the js files must be loaded using DNNJSIncludes.
    
=== .NET Web API Controller Files ===
    
    All WebAPI is done in C#. There are various reasons for this, but the main one is for portability to non-DNN applications.
    All WebAPI applications extend the TbaytelApiController class. In the case of a DNN application this will extend DNNApiController.
    All WebAPI have a namespace. This will contain (at least) a controller class and a router class.
    
    
        namespace Services.QualifiedServices
        {
            public class PreQualController : TbaytelApiController
            {
                [AllowAnonymous]
                [HttpGet]
                public List<ServiceQuals> ServiceInfo(string paramType, string paramValue) 
                {
                    var services = new List<ServiceQuals>();
                    ...
                    return services;
                }
            }
            
            public class RouteMapper : IServiceRouteMapper
            {
                mapRouteManager.MapHttpRoute(
                   moduleFolderName: "QualifiedServices", 
                   routeName: "Default",
                   url:"{controller}/{action}",
                   defaults: new { id = RouteParameter.Optional },
                   namespaces: new[] { "Services.QualifiedServices" }
               );
            
            }
            
        }
    
    The mapping can be a bit confusing; lets talk about the routemapper.
    Assuming you are running dnn from localhost/dnn :
        
        //localhost/dnn/DesktopModules/QualifiedServices/API/PreQual/ServiceInfo?paramType=phonenumber&paramValue=8881234567
        
        breakdown:
        
        //localhost/dnn/DesktopModules  - this is based on your DNN deployment
        QualifiedServices  - moduleFolderName
        PreQual - from the class name PreQualController; they drop the Controller
        ServiceInfo - from the method you want to call
        ?paramType=phonenumber&paramValue=8881234567  - matches the argument in the ServiceInfo method
        
    Some notes on the method itself:
    
        [AllowAnonymous]    - this means anyone can use this
        [HttpGet]           - this means the data returned will be in XML/JSON format, depending on how its called
        List<ServiceQuals>  - List maps nicely to JSON/XML
        
    The storage class ServiceQuals is nothing more than a set of public accessible properties:
        
        public class ServiceQuals
        {
            public string BLP_BILLING_POINT    { get; set; }   
            public string SBR_SUBSCRIPTION_ID  { get; set; }
            public string PhoneNumber          { get; set; }
            ...
       }
        
    This type of class is useful as it can be instantiated:
        
        var service = new ServiceQuals
        {
            BLP_BILLING_POINT    = (string)fixdb(dr["BLP_BILLING_POINT"]),
            SBR_SUBSCRIPTION_ID  = (string)fixdb(dr["SBR_SUBSCRIPTION_ID"]),
            PhoneNumber          = (string)fixdb(dr["PhoneNumber"]),
            SBR_HOUSE_NUMBER     = (string)fixdb(dr["SBR_HOUSE_NUMBER"]),
            ...
        }
    

     
        
=== Conclusions ===

    

